\documentclass[a4paper,10pt]{article}
\usepackage{minted}
\usepackage{amsmath}

\begin{document}

\section*{Exercise 1}
    \begin{enumerate}
        \item Not frequently used, Aging, not recently used
        \item Address translation needs to be fast and if the virtual address space is large, the page table will be large. Local vs. global page allocation, locking pages
        \item It has to make a large number of references to a small number of pages.
        \item Safety (control over virtualized resources, if one VM crashes, the others continue to run, isolation of VMs, i.e. if one is infected, it does not spread), Fidelity (identical bahaviour of running in VM or bare metal)
        \item The transition between an operating system and the hypervisor
        \item Virtualization abstracts hardware and isolates operating systems while containers abstract operating systems and isolate processes
        \item Binary translation replaces instructions of the guest OS on the fly by the according ones of the host or hypervisor. Hardware based approaches result in lots of traps whicgh thrash the CPU caches, branch prediction tables and TLB entries. Thus binary translation may be faster as it simply replaces critical instructions with ones that emulate the very same.
    \end{enumerate}

\section*{Exercise 2}
    \begin{enumerate}
        \item Instruktion auf zwei Pages verteilt, erster und zweiter Operand jeweils über pages
        \item $\frac{2^{48}}{2^{13}} = 2^{35} Pages$
        \item Der Programmcode nimmt exakt die Hälfte des Addressraums ein und ist perfekt aligned mit der Page size ($8$ Pages $\cdot 4$ KiB/Page $= 32$ KiB. Die Daten umfassen 2 Byte mehr als mit 4 Pages speicherbar wären. Die Daten bennötigen also 5 Pages. Der Stack bennötigt 4 pages, was insgesamt zu 17 Pages führt. Da aber nur 16 verfügbar sind passt der Prozess nicht in den Addressraum
        \item Mit 512B Page größe, stehen insgesamt 128 Pages zur Verfügung. 64 davon bennötigt der Programmcode, 33 Pages werden für die Daten bennötigt und 31 für den Stack. Damit passt der Prozess in den Addressraum
    \end{enumerate}

\section*{Exercise 3}
    \begin{enumerate}
        \item 2
        \item 0
        \item 1
        \item 0
    \end{enumerate}

\section*{Exercise 4}
    \begin{enumerate}
        \item 1, Prints the first value of the first subarray
        \item 1, prints the starting address of the array which is also the staring address of the first subarray which is the first element of the first subarray
        \item 2, adds one integer step to the address of the first element of the first subarray
        \item 3, adds one step to the address of the outer array, i.e. gets the address of the first element of the second subarray
        \item as above
        \item the innermost addition adds two subarray steps to the address of the array, i.e. this is the address of the third subarray. by subtracting one, we arrive at the second element of the second subarray, i.e. 4 is printed
    \end{enumerate}


\section*{Exercise 5}
    \begin{enumerate}
        \item $\frac{s}{p} \cdot e + p/2$ Pages per process on average each having an entry size of e 
        \item The smaller the page size, the smaller the second term, but the higher the first one. The otherway round, the larger the page size, the less entries, but the more thrashing
        \item 
        \item
    \end{enumerate}

\end{document}
